<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clock Tree Synthesis | PD Blog</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1><a href="index.html">ğŸ”§ Physical Design Blog</a></h1>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="04_Placement.html">â† Prev</a>
                <a href="06_Routing.html">Next â†’</a>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="article-header">
            <span class="article-number">Part 5 of 10</span>
            <h1>Clock Tree Synthesis (CTS)</h1>
            <p class="subtitle">Distributing the clock with minimal skew</p>
            <p class="author">By <strong>Praveen Kumar Vagala</strong></p>
            <div class="view-counter">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
                <span class="view-count">1,085</span> views
            </div>
        </div>

        <h2>Why CTS Matters</h2>
        <p>Clock must reach all flip-flops at nearly the same time.</p>

<div class="diagram">Without CTS:                 With CTS:

CLK â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â–º FF1      CLK â”€â”€â”¬â”€â”€ BUF â”€â”€â”¬â”€â”€ BUF â”€â”€â–º FF1
         â”‚                        â”‚         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â–º FF2            â”‚         â””â”€â”€ BUF â”€â”€â–º FF2
                   â”‚              â”‚
                   â””â–º FF3         â””â”€â”€ BUF â”€â”€â”¬â”€â”€ BUF â”€â”€â–º FF3
                                            â”‚
Clock reaches FFs at                        â””â”€â”€ BUF â”€â”€â–º FF4
different times!            
                            Balanced tree - clock arrives together!</div>

        <h2>Key CTS Terms</h2>
        <table>
            <tr><th>Term</th><th>Definition</th></tr>
            <tr><td>Clock Source</td><td>Origin of clock (PLL, input pin)</td></tr>
            <tr><td>Clock Sink</td><td>Destination (flip-flop clock pins)</td></tr>
            <tr><td>Insertion Delay</td><td>Time from source to sink</td></tr>
            <tr><td>Skew</td><td>Difference in arrival times between sinks</td></tr>
            <tr><td>Latency</td><td>Average delay from source to sinks</td></tr>
        </table>

        <h2>Clock Skew</h2>

<div class="diagram">             CLK Source
                 â”‚
           â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
           â”‚           â”‚
         BUF         BUF
           â”‚           â”‚
       â”Œâ”€â”€â”€â”´â”€â”€â”€â”   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
       â”‚       â”‚   â”‚       â”‚
     FF1     FF2  FF3    FF4
     
Arrival times:
  FF1: 1.2ns
  FF2: 1.3ns
  FF3: 1.1ns
  FF4: 1.25ns
  
Skew = max - min = 1.3 - 1.1 = 0.2ns</div>

        <h3>Why Skew Matters</h3>
<pre><code>Hold time requirement:
  Tcq + Tcomb > Thold + Tskew

If skew is large â†’ hold violations!

Setup time:
  Tcq + Tcomb + Tsetup < Tperiod + Tskew

Positive skew helps setup (data has more time)</code></pre>

        <h2>Clock Tree Topologies</h2>

        <h3>H-Tree</h3>
<div class="diagram">              CLK
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
       â”‚               â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”       â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   â”‚       â”‚       â”‚       â”‚
â”Œâ”€â”€â”´â”€â”€â” â”Œâ”€â”€â”´â”€â”€â” â”Œâ”€â”€â”´â”€â”€â” â”Œâ”€â”€â”´â”€â”€â”
â”‚     â”‚ â”‚     â”‚ â”‚     â”‚ â”‚     â”‚
FF   FF FF   FF FF   FF FF   FF

H-Tree: Symmetric, equal path lengths
Good for uniform sink distribution</div>

        <h3>Fishbone</h3>
<div class="diagram">CLK â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
      â–¼     â–¼     â–¼     â–¼     â–¼     â–¼
     FF    FF    FF    FF    FF    FF

Fishbone: Central spine with branches
Good for row-based designs</div>

        <h2>CTS Flow</h2>

<div class="diagram">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Define Clock Tree Specification    â”‚
â”‚    â€¢ Target skew, max latency         â”‚
â”‚    â€¢ Buffer types to use              â”‚
â”‚    â€¢ Routing layers                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. Build Clock Tree                   â”‚
â”‚    â€¢ Insert buffers/inverters         â”‚
â”‚    â€¢ Balance delays                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. Route Clock Nets                   â”‚
â”‚    â€¢ Use preferred clock layers       â”‚
â”‚    â€¢ Non-default rules (NDR)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. Optimize                           â”‚
â”‚    â€¢ Fix skew violations              â”‚
â”‚    â€¢ Balance insertion delay          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>

        <h2>Clock Tree Buffers</h2>
        <p>Special cells designed for clock trees:</p>

        <table>
            <tr><th>Property</th><th>Clock Buffer</th><th>Regular Buffer</th></tr>
            <tr><td>Drive strength</td><td>High</td><td>Various</td></tr>
            <tr><td>Balanced rise/fall</td><td>Yes</td><td>Not always</td></tr>
            <tr><td>Low jitter</td><td>Yes</td><td>Not optimized</td></tr>
        </table>

        <h2>CTS Constraints</h2>
<pre><code># Clock tree specification (Innovus)
create_ccopt_clock_tree_spec

set_ccopt_property -clock_tree clk \
  -target_skew 50ps \
  -target_max_trans 100ps \
  -buffer_cells {CLKBUF_X8 CLKBUF_X16}

# Clock routing rules
set_ccopt_property -routing_rule clk_routing_rule
  -preferred_layers {M4 M5}
  -width 0.2
  -spacing 0.2</code></pre>

        <h2>Non-Default Rules (NDR)</h2>
        <p>Clock nets use wider wires and more spacing for reliability.</p>

<div class="diagram">Regular routing:        Clock routing (NDR):

  â•â•â•  â•â•â•  â•â•â•           â•â•â•â•â•â•â•â•
  â”€â”€â”€  â”€â”€â”€  â”€â”€â”€           
  â•â•â•  â•â•â•  â•â•â•              â•â•â•
                          
Minimum width/space       2x width, 2x space
                          Lower resistance,
                          Less coupling</div>

        <h2>Useful Skew</h2>
        <p>Sometimes intentional skew helps timing!</p>

<div class="diagram">Problem: Setup violation on path Aâ†’B

    CLKâ”€â”¬â”€â–º FF_A â”€â”€â”€â”€(long path)â”€â”€â”€â”€â–º FF_B
        â”‚       
    Without skew: Data arrives late!

Solution: Add latency to FF_B clock (useful skew)

    CLKâ”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º FF_A â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚
        â””â”€â”€ BUF â”€â–º FF_B â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
             Clock arrives later,
             data has more time!</div>

        <h2>CTS Commands (Innovus)</h2>
<pre><code># Pre-CTS checks
checkClockTree

# Run CTS
ccopt_design

# Or step by step:
ccopt_design -cts   # Build tree
ccopt_design -hold  # Fix hold violations

# Reports
report_ccopt_clock_trees
report_ccopt_skew_groups

# Check quality
reportClockTree -summary</code></pre>

        <h2>Post-CTS Optimization</h2>
        <p>After CTS, clock is fixed. Now optimize data paths:</p>

<pre><code># Post-CTS optimization
optDesign -postCTS

# Fix hold violations
optDesign -postCTS -hold

# Incremental optimization
optDesign -postCTS -incr</code></pre>

        <h2>CTS Quality Metrics</h2>
        <table>
            <tr><th>Metric</th><th>Good Target</th></tr>
            <tr><td>Clock skew</td><td>< 100ps (advanced nodes)</td></tr>
            <tr><td>Max insertion delay</td><td>Depends on clock period</td></tr>
            <tr><td>Buffer count</td><td>Minimize (power)</td></tr>
            <tr><td>Hold violations</td><td>0 (after fixing)</td></tr>
        </table>

        <div class="summary">
            <h3>Summary</h3>
            <table>
                <tr><th>Concept</th><th>Key Point</th></tr>
                <tr><td>Skew</td><td>Difference in clock arrival times</td></tr>
                <tr><td>Latency</td><td>Delay from source to sinks</td></tr>
                <tr><td>CTS goal</td><td>Minimize skew, balance tree</td></tr>
                <tr><td>NDR</td><td>Wider wires for clock nets</td></tr>
                <tr><td>Useful skew</td><td>Intentional skew for timing</td></tr>
            </table>
        </div>

        <div class="nav-buttons">
            <a href="04_Placement.html" class="nav-btn prev">â† Placement</a>
            <a href="06_Routing.html" class="nav-btn next">Routing â†’</a>
        </div>
    </div>
    
    <div class="footer">
        <p>Physical Design Blog Series | Part 5 of 10</p>
    </div>
</body>
</html>
